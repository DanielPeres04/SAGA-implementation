#   Objective: generate a population containing several MSAs, all contaning homologous biological sequences
#        The population will be a dictionary of alignement objects and their scores 
#        Each generation will contain different MSAs (organisms)
#        The fittest individuals (top 50%) will be kept in the next generation
#        The remaining individuals will be created from mutaion events or crossover between selected parents
from copy import deepcopy
from crossover_protein import clean_alignement, get_offspring
import math, random, mutations



class Generation:

    def __init__(self, standard_msa, population_size, pad_limit, submat, crossover_probability):
        self.population_size = population_size
        self.submat = submat
        self.pad_limit = pad_limit
        self.generations_scores = {}
        self.generation_total_fitness = 0
        self.generation_max_SP = 0
        #when initialized becomes 0
        self.current_generation = -1
        self.population = self.create_gen_0(standard_msa, population_size, pad_limit)
        ##### should it be the max score or the total score of the population? #####
        self.crossover_probability = crossover_probability
        self.stop = False

    def __str__(self):
        return "alignement_instance"

    def get_best_alignement(self):
        pass

    def create_gen_0(self, standard_msa, population_size, pad_limit):
        
#       creates the first generation (gen 0) composed of "population size" alignements
#       adds the total fitness score of gen 0 to the generation score instance variable
        new_population = {}
        min_score = math.inf
        max_score = -(math.inf)
       
        for i in range(1,population_size+1):

#            deepcopy creats an independent copy of the object and all lists within it
            current_msa = deepcopy(standard_msa)
            current_msa.add_variability(pad_limit)
            current_msa = clean_alignement(current_msa)
#           current score is obtained from a substitution matrix
            current_score = current_msa.get_score(self.get_submat())
#           record minimum score
            if current_score < min_score:
                min_score = current_score
            if current_score > max_score:
                max_score = current_score

#           record MSAs and theirs scores
            new_population[f"MSA{i}"] = {"alignement": current_msa, "SP_score": current_score}
        
#       update the best overall score
        self.generation_max_SP = max_score

        return self.SP_to_fitness(new_population, min_score)


    def update_generation(self):
        """
        Creates a braand new generation from the previous
        The top 50% alignements of the previous generation are kept. The remaining 50% of this generation are \
        generated by either mutation or crossover events.
        The parents of the new offspring are selected by their EO rounded values 
        Also updates the dictionary of generation score, with the number of the population and its total score
        """
#       first select top individuals from the population
        top_50_SP, top_50_SP_min, top_50_SP_max = self.get_top_50_SP_dict()

#       then obtain the parent candidates of the parent population
#       each pair of parents can be subjected to crossover or mutation events
#       a list of offspring members is then added to the next generation
#       all individuals are renamed to msa1-100
        nextgen_parents = self.get_nextgen_parents()
        #print(nextgen_parents)
        #print("next gen parents len:", len(nextgen_parents))

#       next step is to obtain the offpring/mutated individuals
#       the sp_score of the offspring/mutated individuals will be calculated separately (already calculated for top50)
#       the fitness score will be calculated will both top50 and the offspring
        other_50_SP, other_50_SP_min, other_50_SP_max = self.get_other_50_SP_dict(nextgen_parents)
        #print("top 50 len:",len(top_50_SP), "other 50 len:", len(other_50_SP))

#       get the overall minimum SP score
        next_gen_SP_min = min(top_50_SP_min, other_50_SP_min)
        next_gen_SP_max = max(top_50_SP_max, other_50_SP_max)
#       merge the two dicts for a complete population
        next_gen_SP = top_50_SP | other_50_SP
        #print("nex gen dict len:", len(next_gen_SP))
#       calculate the fitness scores for the population
        nextgen_dict = self.SP_to_fitness(next_gen_SP, next_gen_SP_min)
#       now we can update the current generation
        self.generation_max_SP = next_gen_SP_max
        self.population = nextgen_dict
        self.is_population_better()
        #self.generations_scores[int(len(self.generations_scores))] = self.get_generation_max_fitness()


    def SP_to_fitness(self, SP_population, min_score):
        """
        Converts the Sum of Pairs (SP) scores into Fitness scores in the SP_population dict
        
        :param SP_population:  population of MSAs with SP scores
        :param min_score: minimum scores from the SP scores of the population
        """

        total_fitness_score = 0
        max_fitness_score = 0
        fitness_population = {}
#       calculate individual MSA and global fitness score
        for alignement in SP_population.values():
            score = alignement["SP_score"]
            current_fitness_score = Generation.calculate_fitness(score, min_score)
            alignement["Fitness_score"] = current_fitness_score
#           current fitness score is added to the total score
#           max_fitness score is updated
            total_fitness_score += current_fitness_score
            if current_fitness_score > max_fitness_score:
                max_fitness_score = current_fitness_score

#       the generation score is added to the generations_scores dictionary
        self.generation_total_fitness = total_fitness_score
        self.generations_scores[len(self.generations_scores)] = max_fitness_score
        self.current_generation += 1
#       sort by the score to then get the top50
#       population_decreasing order will store the key: value pairs in tuples, by the correct order
#       this was necessary since dictionaries cannot be directly reordered
        population_decreasing_order = sorted(SP_population.items(), key = lambda item: item[1]["Fitness_score"], reverse = True)
        for msa in population_decreasing_order:
            fitness_population[msa[0]] = msa[1]

        return fitness_population
    
    def get_other_50_SP_dict(self, parent_list, break_positions_1_list = None):
        """
        Retrieves a dictionary including the remaining 50 individuals of the new generation and their \
        corresponding SP scores
        
        :param parent_list: a list including the parents of the new offspring/mutated alignements.
        :param break_positions_1_list: A list with pre-defined break positions for the crossover operation
        """
        other_50 = []

#       get parent pairs from parent list
        for i in range(0, len(parent_list)-1, 2):
            parent_1_id = parent_list[i]
            parent_1 = self.get_population()[parent_1_id]["alignement"]
            parent_2_id = parent_list[i+1]
            parent_2 = self.get_population()[parent_2_id]["alignement"]

#           choose between crossover and mutation
            operator = random.choices(population = ["crossover", "mutation"], weights = [self.crossover_probability, 1- self.crossover_probability])[0]
            if operator == "crossover":
                break_positions_1 = []
                
                if break_positions_1_list:
                    break_positions_1 = break_positions_1_list   
                else: 
                    #for all sequences in the alignement
                    ###### Perguntar ao professor ######
                    #guarantee that there are no errors
                    break_positions_1 = [random.choice(range(2*self.pad_limit, len(parent_1)-(2*self.pad_limit)))]*13
                child_1, child_2 = get_offspring(parent_1, parent_2, break_positions_1)
#               only add one of the children randomly
                chosen_child = random.choice([child_1,child_2])
                #print(chosen_child)
                other_50.append(chosen_child)
            if operator == "mutation":

#               pick a random parent
                chosen_parent = random.choice([parent_1,parent_2])
#               pick a random mutation
                chosen_mutation = mutations.pick_random_mutation()
                mutated_msa = chosen_mutation(chosen_parent)
                other_50.append(mutated_msa)
        #print("len other 50:", len(other_50))
        
        return self.score_other_50(other_50)

    def score_other_50(self, alignement_list):
        """
        Retrieves the SP score of the other 50 percent individuals of the next generation
        
        :param alignement_list: a list containing the MSAs of the other 50 percent individuals
        """

        other_50_dict = {}
        other_min = math.inf
        other_max = -(math.inf)
#       we start the indexing from the half of the population count
        i_start = len(self.get_population())/2     
        for i, msa in enumerate(alignement_list):

            msa_i = i + i_start
            #print("msa_i", msa_i)
            current_score = msa.get_score(self.get_submat())
            if current_score < other_min:
                other_min = current_score
            if current_score > other_max:
                other_max = current_score
            other_50_dict[f"MSA{msa_i}"] = {"alignement" : msa, "SP_score" : current_score}
        
        return other_50_dict, other_min, other_max


    def get_nextgen_parents(self):
        """
        Retrieves  a list of identifiers of random alignements from the current population according to their weight on the overall score
        These parents can be subjected to breeding or to random mutations
        The number of selected parents is equal to the size of the current generation
        
        """

        selected_parents_1 = []
        selected_parents_2 = []
        all_rems = {}
        total_rem = 0

#       first need to create the roulette
#       the parent selection using this roulette will be based on the EO score of the aligments
#       the EO floor dictates deterministically at least how many times the alignement will be selected
#       the rem dictates the probability of the alignement being selected for the remaining spaces
        for msa_id, msa in self.get_population().items():
                current_fitness_score = msa["Fitness_score"]
                current_EO_floor, current_EO_rem = self.calculate_EO(current_fitness_score)
#               load alignements deterministically
                for _ in range(current_EO_floor):
                    selected_parents_1.append(msa_id)
#               load remainders into the final roulette
                total_rem += current_EO_rem
                all_rems[msa_id] = current_EO_rem

        missing_slots = (self.population_size) - len(selected_parents_1)
#       if total rem is 0, the population has hit stagnation
#       thus we change self.stop to True

        if total_rem == 0:
            self.stop = True
            #assume equal probability
            selected_parents_2 = random.choices(list(self.population.keys()), k = missing_slots)
        else:
#           now for the weighted random selection
#           total candidate number is equal to the population size
#           get remaining parent candidates
            selected_parents_2 = self.rem_to_parents(all_rems, total_rem, missing_slots)

        final_parents = selected_parents_1 + selected_parents_2
        random.shuffle(final_parents)

#       output the shuffled list of parents
        return final_parents

    @staticmethod
    def calculate_fitness(current_score, min_score):
        """
        Calculates the fitness of an alignement, using Sum of Pairs scores as input
        Calculates the difference between the current score and the minimum observed score. 1 is \
        summed to guarantee all scores are higher than 0
        
        :param min_score: current score obtained from a given alignement
        :param min_score: the minimum score obtained from the population of alignements
        """
        return current_score - min_score + 1

    def get_top_50_SP_dict(self):
        """
        Returns the top 50% individuals from the descending order population dictionary self.population, without the fitness scores
        """
        top_min = math.inf
        top_max = -(math.inf)
        pop_copy = deepcopy(self.population)
        #print("self population len:", len(self.population))
#       get a tuple with the msa id and the scores
        top_50_dict = {}
        for i, msa in enumerate(pop_copy.values()):
#       we only want the top 50 alignements in the dict
            if i == (len(self.get_population())/2):
                break
#           The fitness scores are discarded since the min_SP_score may change in the new population
            alignement = msa["alignement"]
            current_score = msa["SP_score"]
            if current_score < top_min:
                top_min = current_score
            if current_score > top_max:
                top_max = current_score
            top_50_dict[f"MSA{i}"] = {"alignement" : alignement, "SP_score" :current_score}
        #print("top 50 len:", len(top_50_dict))
        return top_50_dict, top_min, top_max

    def calculate_EO(self, fitness_score):
        """
        Calculates the Expected Offspring (EO) value for a given alignement
        
        :param alignement: A given alignement from a generation
        """

        average_fitness = self.generation_total_fitness/len(self.population)
#       returns the integer part of the EO
        EO = fitness_score/average_fitness
        EO_floored = math.floor(EO)
        EO_rem = EO - EO_floored
        return EO_floored, EO_rem
    
    @staticmethod
    def rem_to_parents(rems_dict, total_rem, free_slots):
        """
        From a dictionary {alignnement_id: rem} and a total of rem values, calculates the weight of each alignement \
        to the rem total and outputs the remaining parents.
        
        
        :param rems_dict: a dictionary containing alignements and the correspondent rem values
        :param total_rem: total sum of the rems
        :param free_slots: the slots of the parents list to fill up
        """
        alignements = list(rems_dict.keys())
        rems = list(rems_dict.values())
        proportions = [rem / total_rem for rem in rems]

#       obtain list of parents
        remaining_parents = random.choices(population = alignements, weights = proportions, k = free_slots)
        return remaining_parents
        
        
    def is_population_better(self):
        """
        Checks if the current population has a significantly higher score than the previous
        Returns True if the percentage of individuals with top score is higher than the crossover probability
        
        """
        if self.get_fitness_identity_percentage() > self.crossover_probability:
            self.stop = True

    def get_current_generation(self):
        """
        Retrieves the identifier of the current generation
        """
        return self.current_generation

    def get_generation_max_SP(self):
        """
        Retrieves the highest SP score of the current generation
        """
        return self.generation_max_SP

    def get_generation_max_fitness(self):
        """
        Retrieves the highest Fitness score of the current generation
        """
        return self.generations_scores[self.current_generation]
    
    def get_generation_average_fitness(self):
        """
        Retrieves the average SP value of the current generation
        """
        return self.generation_total_fitness/self.population_size
    
    def get_fitness_identity_percentage(self):
        count = 0
        for msa in self.population.values():
            if msa["Fitness_score"] == self.get_generation_max_fitness():
                count += 1
        return round(count/self.population_size, 2)

    def get_population(self):
        return self.population
    
    def get_submat(self):
        return self.submat
    
    def get_all_fitness(self):
        fitness_scores = []
        for al in self.population.values():
            fitness_scores.append(al["Fitness_score"])
        return fitness_scores
    
    def get_all_SP(self):
        SP_scores = []
        for al in self.population.values():
            SP_scores.append(al["SP_score"])
        return SP_scores
    
    def get_all_alignements(self):
        alignements = []
        for al in self.population.values():
            alignements.append(al["alignement"])
        return alignements
    
    def check_status(self):
        return self.stop 
    
    @staticmethod
    def create_output_file(output_name):
        """
        creates an output file to store the best MSAs
        
        :param output_name: The name of the output file to be created
        """
        with open(f"{output_name}.txt", "w") as out:
            out.write("##### Best MSAs in all Cycles #####" + "\n")
            out.write("\n")
    
    def output_best_MSA(self, output_name):
        """
        Retrieves the best MSA of the current generataion
        Appends it to a output file
        
        :param output_name: the name of the output file
        """
        best_MSA = self.population["MSA1"]["alignement"]
        best_MSA_seqs = best_MSA.get_seqs()
        with open(f"{output_name}.txt", "a") as out:
            out.write("MSA score - " + str(self.generation_max_SP) + "\n")
            for seq in best_MSA_seqs:
                out.write(seq + "\n")
            for _ in range(3):
                out.write("\n")
